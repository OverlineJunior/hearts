"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[117],{5061:function(e){e.exports=JSON.parse('{"functions":[{"name":"Damage","desc":"Removes health from the target, accepting an optional data table (empty if not given) that will be passed to modifiers and the [Hearts.HumanoidDamaged] event.","params":[{"name":"target","desc":"","lua_type":"Humanoid"},{"name":"amount","desc":"","lua_type":"number"},{"name":"data","desc":"","lua_type":"Data?"}],"returns":[],"function_type":"static","source":{"line":57,"path":"src/init.lua"}},{"name":"Heal","desc":"Adds health to the target, accepting an optional data table (empty if not given) that will be passed to modifiers and the [Hearts.HumanoidHealed] event.","params":[{"name":"target","desc":"","lua_type":"Humanoid"},{"name":"amount","desc":"","lua_type":"number"},{"name":"data","desc":"","lua_type":"Data?"}],"returns":[],"function_type":"static","source":{"line":65,"path":"src/init.lua"}},{"name":"AddModifier","desc":"Adds a function that will be called everytime *target* is either damaged or healed, capable of modifying the health change by returning a different\\nvalue (remaining the same if nothing is returned). Multiple can be used and all are automatically garbage collected when the *target* is destroyed.\\n\\n```lua\\n-- For each time myHumanoid is about to be healed, double the healing.\\nHearts.AddModifier(myHumanoid, function(healthChange: number)\\n    -- If healthChange is positive, it means it is healing, not damaging.\\n    if healthChange > 0 then\\n        return healthChange * 2\\n    end\\nend)\\n\\n-- Because of the modifier, heals 100 health.\\nHearts.Heal(myHumanoid, 50)\\n```","params":[{"name":"target","desc":"","lua_type":"Humanoid"},{"name":"modifierFn","desc":"","lua_type":"(number, Data) -> number?"}],"returns":[{"desc":"","lua_type":"number"}],"function_type":"static","source":{"line":93,"path":"src/init.lua"}},{"name":"AddGlobalModifier","desc":"Similar to [Hearts.AddModifier], but applies to every possible humanoid instead of a specific one.\\n\\n```lua\\n-- For every humanoid, deny letal damage.\\nHearts.AddGlobalModifier(function(humanoid: Humanoid, healthChange: number)\\n    -- If healthChange is damaging and letal, deny it.\\n    if humanoid.Health + healthChange <= 0 then\\n        return 0\\n    end\\nend)\\n\\n-- If myHumanoid had 50 health or less, this call would be ignored because the damage would be letal.\\nHearts.Damage(myHumanoid, 50)\\n```\\n\\nGlobal modifiers can be useful for making sure data is sent the way our whole game expects it to be sent:\\n\\n```lua\\nHearts.AddGlobalModifier(function(_, _, data: Hearts.Data)\\n    assert(data.Source, \'Source not defined\')\\nend)\\n\\n-- All good, the damage source was defined.\\nHearts.Damage(myHumanoid, 20, {\\n    Source = enemyHumanoid,\\n})\\n\\n-- Errors because the damage source was not defined.\\nHearts.Damage(myHumanoid, 20)\\n```","params":[{"name":"globalModifierFn","desc":"","lua_type":"(Humanoid, number, Data) -> number?"}],"returns":[{"desc":"","lua_type":"number"}],"function_type":"static","source":{"line":146,"path":"src/init.lua"}},{"name":"RemoveModifier","desc":"Removes a modifier by its id, which is returned by [Hearts.AddModifier] and [Hearts.AddGlobalModifier].\\n\\n```lua\\n-- Denies every damage and heal directed to myHumanoid.\\nlocal id = Hearts.AddModifier(myHumanoid, function()\\n    return 0\\nend)\\n\\n-- Denied.\\nHearts.Damage(myHumanoid, 50)\\n\\nHearts.RemoveModifier(id)\\n\\n-- Deals 50 damage since the modifier no longer exists.\\nHearts.Damage(myHumanoid, 50)\\n```","params":[{"name":"id","desc":"","lua_type":"number"}],"returns":[],"function_type":"static","source":{"line":172,"path":"src/init.lua"}}],"properties":[{"name":"HumanoidDamaged","desc":"","lua_type":"Signal<Humanoid, number, Data>","tags":["Event"],"source":{"line":47,"path":"src/init.lua"}},{"name":"HumanoidHealed","desc":"","lua_type":"Signal<Humanoid, number, Data>","tags":["Event"],"source":{"line":53,"path":"src/init.lua"}}],"types":[{"name":"Data","desc":"Optional table that can be passed to [Hearts.Damage] and [Hearts.Heal]\'s third parameter, which is then passed to modifiers\\nand the [Hearts.HumanoidDamaged] and [Hearts.HumanoidHealed] events.\\n\\n```lua\\n-- myHumanoid is now a hedgehog, every humanoid that damages it now takes half of that damage.\\nHearts.HumanoidDamaged:Connect(function(target: Humanoid, damage: number, data: Hearts.Data)\\n    if target == myHumanoid and data.Source then\\n        Hearts.Damage(data.Source, damage / 2)\\n    end\\nend)\\n\\nHearts.Damage(myHumanoid, 20, {\\n    Source = enemyHumanoid,\\n})\\n```","lua_type":"{[any]: any?}","source":{"line":23,"path":"src/init.lua"}}],"name":"Hearts","desc":"","source":{"line":40,"path":"src/init.lua"}}')}}]);